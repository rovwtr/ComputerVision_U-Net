# -*- coding: utf-8 -*-
"""Model Evaluator

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GZpAgcvmxcjKJchnKGRdvuNCdDMKcbsv
"""

import torch
from google.colab import drive
drive.mount('/content/drive')

!cat /proc/cpuinfo

""" Parts of the U-Net model """
import torch
import argparse
from PIL import Image
import torch.nn as nn
import torch.nn.functional as F


class DoubleConv(nn.Module):
    """(convolution => [BN] => ReLU) * 2"""

    def __init__(self, in_channels, out_channels, mid_channels=None):
        super().__init__()
        if not mid_channels:
            mid_channels = out_channels
        self.double_conv = nn.Sequential(
            nn.Conv2d(in_channels, mid_channels, kernel_size=3, padding=1, bias=False),
            nn.BatchNorm2d(mid_channels),
            nn.ReLU(inplace=True),
            nn.Conv2d(mid_channels, out_channels, kernel_size=3, padding=1, bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )

    def forward(self, x):
        return self.double_conv(x)


class Down(nn.Module):
    """Downscaling with maxpool then double conv"""

    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.maxpool_conv = nn.Sequential(
            nn.MaxPool2d(2),
            DoubleConv(in_channels, out_channels)
        )

    def forward(self, x):
        return self.maxpool_conv(x)


class Up(nn.Module):
    """Upscaling then double conv"""

    def __init__(self, in_channels, out_channels, bilinear=True):
        super().__init__()

        # if bilinear, use the normal convolutions to reduce the number of channels
        if bilinear:
            self.up = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
            self.conv = DoubleConv(in_channels, out_channels, in_channels // 2)
        else:
            self.up = nn.ConvTranspose2d(in_channels, in_channels // 2, kernel_size=2, stride=2)
            self.conv = DoubleConv(in_channels, out_channels)

    def forward(self, x1, x2):
        x1 = self.up(x1)
        # input is CHW
        diffY = x2.size()[2] - x1.size()[2]
        diffX = x2.size()[3] - x1.size()[3]

        x1 = F.pad(x1, [diffX // 2, diffX - diffX // 2,
                        diffY // 2, diffY - diffY // 2])
        # if you have padding issues, see
        # https://github.com/HaiyongJiang/U-Net-Pytorch-Unstructured-Buggy/commit/0e854509c2cea854e247a9c615f175f76fbb2e3a
        # https://github.com/xiaopeng-liao/Pytorch-UNet/commit/8ebac70e633bac59fc22bb5195e513d5832fb3bd
        x = torch.cat([x2, x1], dim=1)
        return self.conv(x)


class OutConv(nn.Module):
    def __init__(self, in_channels, out_channels):
        super(OutConv, self).__init__()
        self.conv = nn.Conv2d(in_channels, out_channels, kernel_size=1)

    def forward(self, x):
        return self.conv(x)

class UNet(nn.Module):
    def __init__(self, n_channels, n_classes, bilinear=False):
        super(UNet, self).__init__()
        self.n_channels = n_channels
        self.n_classes = n_classes
        self.bilinear = bilinear

        self.inc = (DoubleConv(n_channels, 64))
        self.down1 = (Down(64, 128))
        self.down2 = (Down(128, 256))
        self.down3 = (Down(256, 512))
        factor = 2 if bilinear else 1
        self.down4 = (Down(512, 1024 // factor))
        self.up1 = (Up(1024, 512 // factor, bilinear))
        self.up2 = (Up(512, 256 // factor, bilinear))
        self.up3 = (Up(256, 128 // factor, bilinear))
        self.up4 = (Up(128, 64, bilinear))
        self.outc = (OutConv(64, n_classes))

    def forward(self, x):
        x1 = self.inc(x)
        x2 = self.down1(x1)
        x3 = self.down2(x2)
        x4 = self.down3(x3)
        x5 = self.down4(x4)
        x = self.up1(x5, x4)
        x = self.up2(x, x3)
        x = self.up3(x, x2)
        x = self.up4(x, x1)
        logits = self.outc(x)
        return logits

    def use_checkpointing(self):
        self.inc = torch.utils.checkpoint(self.inc)
        self.down1 = torch.utils.checkpoint(self.down1)
        self.down2 = torch.utils.checkpoint(self.down2)
        self.down3 = torch.utils.checkpoint(self.down3)
        self.down4 = torch.utils.checkpoint(self.down4)
        self.up1 = torch.utils.checkpoint(self.up1)
        self.up2 = torch.utils.checkpoint(self.up2)
        self.up3 = torch.utils.checkpoint(self.up3)
        self.up4 = torch.utils.checkpoint(self.up4)
        self.outc = torch.utils.checkpoint(self.outc)

def get_args():
    parser = argparse.ArgumentParser(description='Train the UNet on images and target masks')
    parser.add_argument('--epochs', '-e', metavar='E', type=int, default=5, help='Number of epochs')
    parser.add_argument('--batch-size', '-b', dest='batch_size', metavar='B', type=int, default=1, help='Batch size')
    parser.add_argument('--learning-rate', '-l', metavar='LR', type=float, default=1e-5,
                        help='Learning rate', dest='lr')
    parser.add_argument('--load', '-f', type=str, default=False, help='Load model from a .pth file')
    parser.add_argument('--scale', '-s', type=float, default=0.5, help='Downscaling factor of the images')
    parser.add_argument('--validation', '-v', dest='val', type=float, default=10.0,
                        help='Percent of the data that is used as validation (0-100)')
    parser.add_argument('--amp', action='store_true', default=False, help='Use mixed precision')
    parser.add_argument('--bilinear', action='store_true', default=False, help='Use bilinear upsampling')
    parser.add_argument('--classes', '-c', type=int, default=2, help='Number of classes')

    return parser.parse_args()

args = get_args()
model = UNet(n_channels=3, n_classes=args.classes, bilinear=args.bilinear)


model.load_state_dict(torch.load('/content/drive/MyDrive/Computer Vision/images/modelstr_15062023_300', map_location=torch.device('cpu')))
model.eval()

import argparse
import logging
import os

import numpy as np
import torch
import torch.nn.functional as F
from PIL import Image
from torchvision import transforms


import matplotlib.pyplot as plt


def plot_img_and_mask(img, mask):
    fig, ax = plt.subplots(1, 2)
    ax[0].set_title('Input image')
    ax[0].imshow(img)
    new = np.asarray(img.copy())
    new[mask == 1] = 255

    new = Image.fromarray(np.uint8((new)))

    ax[1].imshow(new)
    plt.xticks([]), plt.yticks([])
    plt.show()
    # classes = mask.max() + 1
    # fig, ax = plt.subplots(1, classes + 1)
    # ax[0].set_title('Input image')
    # ax[0].imshow(img)
    # for i in range(classes):
    #     ax[i + 1].set_title(f'Mask (class {i + 1})')
    #     ax[i + 1].imshow(mask == i)
    # plt.xticks([]), plt.yticks([])
    # plt.show()

def plot_gt_and_mask(mask, mask_pred):
    mask = np.asarray(mask)
    mask_pred = np.asarray(mask_pred)
    acc = (np.count_nonzero(np.equal(mask, mask_pred)))/(256*256)
    TP = np.count_nonzero(np.logical_and((mask == 1), (mask_pred == 1)))
    FP = np.count_nonzero(np.logical_and((mask == 0), (mask_pred == 1)))
    FN = np.count_nonzero(np.logical_and((mask == 1), (mask_pred == 0)))
    TN = np.count_nonzero(np.logical_and((mask == 0), (mask_pred == 0)))

    print(f"Accuracy: {acc}")
    print(f"Precision {TP/(TP+FP)}")
    print(f"Recall {TP/(TP+FN)}")

    precision = TP/(TP+FP)
    recall = TP/(TP+FN)


    return acc, precision, recall

    # classes = mask.max() + 1
    # fig, ax = plt.subplots(1, classes + 1)
    # ax[0].set_title('Ground Truth')
    # ax[0].imshow(img)
    # for i in range(classes):
    #     ax[i + 1].set_title(f'Mask (class {i + 1})')
    #     ax[i + 1].imshow(mask == i)
    # plt.xticks([]), plt.yticks([])
    # plt.show()

def predict_img(net,
                full_img,
                device,
                scale_factor=1,
                out_threshold=0.5):
    net.eval()
    img = torch.from_numpy(preprocess(None, full_img, scale_factor, is_mask=False))
    img = img.unsqueeze(0)
    img = img.to(device=device, dtype=torch.float32)

    with torch.no_grad():
        output = net(img).cpu()
        output = F.interpolate(output, (full_img.size[1], full_img.size[0]), mode='bilinear')
        if net.n_classes > 1:
            mask = output.argmax(dim=1)
        else:
            mask = torch.sigmoid(output) > out_threshold

    return mask[0].long().squeeze().numpy()

def mask_to_image(mask: np.ndarray, mask_values):
    if isinstance(mask_values[0], list):
        out = np.zeros((mask.shape[-2], mask.shape[-1], len(mask_values[0])), dtype=np.uint8)
    elif mask_values == [0, 1]:
        out = np.zeros((mask.shape[-2], mask.shape[-1]), dtype=bool)
    else:
        out = np.zeros((mask.shape[-2], mask.shape[-1]), dtype=np.uint8)

    if mask.ndim == 3:
        mask = np.argmax(mask, axis=0)

    for i, v in enumerate(mask_values):
        out[mask == i] = v

    return Image.fromarray(out)

def preprocess(mask_values, pil_img, scale, is_mask):
    w, h = pil_img.size
    newW, newH = int(scale * w), int(scale * h)
    assert newW > 0 and newH > 0, 'Scale is too small, resized images would have no pixel'
    pil_img = pil_img.resize((newW, newH), resample=Image.NEAREST if is_mask else Image.BICUBIC)
    img = np.asarray(pil_img)

    if is_mask:
        mask = np.zeros((newH, newW), dtype=np.int64)
        for i, v in enumerate(mask_values):
            if img.ndim == 2:
                mask[img == v] = i
            else:
                mask[(img == v).all(-1)] = i

        return mask

    else:
        if img.ndim == 2:
            img = img[np.newaxis, ...]
        else:
            img = img.transpose((2, 0, 1))

        if (img > 1).any():
            img = img / 255.0

        return img

device = 'cpu'

def plot_im_and_mask_orig(img, mask):
    classes = mask.max() + 1
    fig, ax = plt.subplots(1, classes + 1)
    ax[0].set_title('Input image')
    ax[0].imshow(img)
    for i in range(classes):
        ax[i + 1].set_title(f'Mask (class {i + 1})')
        ax[i + 1].imshow(mask == i)
    plt.xticks([]), plt.yticks([])
    plt.show()

def plot_gt_and_mask_orig(img, mask):
    classes = mask.max() + 1
    fig, ax = plt.subplots(1, classes + 1)
    ax[0].set_title('Ground Truth')
    ax[0].imshow(img)
    for i in range(classes):
        ax[i + 1].set_title(f'Mask (class {i + 1})')
        ax[i + 1].imshow(mask == i)
    plt.xticks([]), plt.yticks([])
    plt.show()

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg850.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg850.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
# %time
plot_im_and_mask_orig(img, mask_p)
plot_gt_and_mask_orig(mask, mask_p)

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg810.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg810.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
# %time
plot_img_and_mask(img, mask_p)
plot_gt_and_mask(mask, mask_p)

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg820.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg820.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.7,
                           out_threshold=0.5,
                           device=device)
# %time
plot_img_and_mask(img, mask_p)
plot_gt_and_mask(mask, mask_p)

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg830.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg830.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
# %time
plot_img_and_mask(img, mask_p)
plot_gt_and_mask(mask, mask_p)

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg840.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg840.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
# %time
plot_img_and_mask(img, mask_p)
plot_gt_and_mask(mask, mask_p)

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg850.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg850.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
# %time
plot_img_and_mask(img, mask_p)
plot_gt_and_mask(mask, mask_p)

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg860.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg860.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
# %time
plot_img_and_mask(img, mask_p)
plot_gt_and_mask(mask, mask_p)

# Commented out IPython magic to ensure Python compatibility.
img = Image.open('/content/drive/MyDrive/Computer Vision/testsetx/mg870.jpg')
mask = Image.open('/content/drive/MyDrive/Computer Vision/testsety/mg870.gif')
# %time
mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
# %time
plot_img_and_mask(img, mask_p)
plot_gt_and_mask(mask, mask_p)

import os

directory = '/content/drive/MyDrive/Computer Vision/Test'
for filename in os.listdir(directory):
    f = os.path.join(directory, filename)
    if os.path.isfile(f):
        img = Image.open(f)
        img = img.resize((256, 256), resample=Image.BICUBIC)
        mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
        plot_img_and_mask(img, mask_p)

from PIL import Image
img = Image.open('/content/drive/MyDrive/Computer Vision/images/data_augmented_full/data_augmented_str/mg160.jpg')
img = img.resize((256, 256), resample=Image.BICUBIC)

mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                    out_threshold=0.5,
                    device=device)
plot_img_and_mask(img, mask_p)

import os

directory = '/content/drive/MyDrive/Computer Vision/test_unseen'
for filename in os.listdir(directory):
    f = os.path.join(directory, filename)
    if os.path.isfile(f):
        img = Image.open(f)

        img = img.resize((256, 256), resample=Image.BICUBIC)

        img = img.rotate(-90)
        mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                           out_threshold=0.5,
                           device=device)
        plot_img_and_mask(img, mask_p)

import os

accs = []
prec = []
recalls = []

directory = '/content/drive/MyDrive/Computer Vision/testsetx'
gt_dir = '/content/drive/MyDrive/Computer Vision/testsety'
for filename in os.listdir(directory):
    f = os.path.join(directory, filename)
    if os.path.isfile(f):
      for gt_file in os.listdir(gt_dir):
        mask = os.path.join(gt_dir, gt_file)
        if os.path.isfile(mask):
          if (filename[:5] == gt_file[:5]):
            img = Image.open(f)
            gt_mask = Image.open(mask)

            # img = img.resize((256, 256), resample=Image.BICUBIC)

            # img = img.rotate(-90)
            mask_p = predict_img(net=model, full_img=img, scale_factor=0.5,
                              out_threshold=0.5,
                              device=device)
            plot_img_and_mask(img, mask_p)
            accuracy, precision, recall = plot_gt_and_mask(gt_mask, mask_p)

            accs.append(accuracy)
            prec.append(precision)
            recalls.append(recall)

print("Average accuracy: ", sum(accs)/len(accs))
print("Average precision: ", sum(prec)/len(prec))
print("Average recall: ", sum(recalls)/len(recalls))

